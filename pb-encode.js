const textEncoder = new TextEncoder()

function encodeLink (link, bytes) {
  let i = bytes.length
  if (typeof link.Tsize === 'number') {
    i = encodeVarintMerkledag(bytes, i, link.Tsize)
    i--
    bytes[i] = 0x18
  }
  if (typeof link.Name === 'string') {
    const nameBytes = textEncoder.encode(link.Name)
    i -= nameBytes.length
    bytes.set(nameBytes, i)
    i = encodeVarintMerkledag(bytes, i, nameBytes.length)
    i--
    bytes[i] = 0x12
  }
  if (link.Hash) {
    i -= link.Hash.length
    bytes.set(link.Hash, i)
    i = encodeVarintMerkledag(bytes, i, link.Hash.length)
    i--
    bytes[i] = 0xa
  }
  return bytes.length - i
}

function encodeNode (node) {
  const size = sizeNode(node)
  const bytes = new Uint8Array(size)
  let i = size
  if (node.Data) {
    i -= node.Data.length
    bytes.set(node.Data, i)
    i = encodeVarintMerkledag(bytes, i, node.Data.length)
    i--
    bytes[i] = 0xa
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size = encodeLink(node.Links[index], bytes.subarray(0, i))
      i -= size
      i = encodeVarintMerkledag(bytes, i, size)
      i--
      bytes[i] = 0x12
    }
  }
  return bytes
}

function encodeVarintMerkledag (bytes, offset, v) {
  offset -= sov(v)
  const base = offset
  while (v >= (1 << 7)) {
    bytes[offset] = (v & 0x7f) | 0x80
    v >>= 7
    offset++
  }
  bytes[offset] = v
  return base
}

function sizeLink (link) {
  let n = 0
  if (link.Hash) {
    const l = link.Hash.length
    n += 1 + l + sov(l)
  }
  if (typeof link.Name === 'string') {
    const l = textEncoder.encode(link.Name).length
    n += 1 + l + sov(l)
  }
  if (typeof link.Tsize === 'number') {
    n += 1 + sov(link.Tsize)
  }
  return n
}

function sizeNode (node) {
  let n = 0
  if (node.Data) {
    const l = node.Data.length
    n += 1 + l + sov(l)
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link)
      n += 1 + l + sov(l)
    }
  }
  return n
}

function sov (x) {
  return Math.floor((len64(x | 1) + 6) / 7)
}

// golang math/bits
function len64 (x) {
  let n = 0
  /* c8 ignore next 3 */
  if (!Number.isSafeInteger(x)) {
    throw new Error('unsafe integer')
  }
  if (x >= (1 << 16)) {
    x >>= 16
    n += 16
  }
  if (x >= (1 << 8)) {
    x >>= 8
    n += 8
  }
  return n + len8tab[x]
}

// golang math/bits
const len8tab = [
  0x00, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
  0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
  0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
  0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
]

export { encodeNode, encodeLink }
